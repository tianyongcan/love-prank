<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D çµé­‚ç²’å­æ£€æµ‹</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; }
        canvas { display: block; }
        
        /* ç•Œé¢ UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®©é¼ æ ‡èƒ½ç©¿é€ UI æ“ä½œ 3D ç²’å­ */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        h1 {
            color: white;
            font-weight: 300;
            letter-spacing: 5px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            font-size: 2rem;
            text-align: center;
        }

        #status {
            color: #aaa;
            margin-bottom: 40px;
            font-size: 1rem;
            min-height: 24px;
        }

        /* æŒ‰é’®æ ·å¼ */
        #startBtn {
            pointer-events: auto; /* åªæœ‰æŒ‰é’®èƒ½ç‚¹å‡» */
            padding: 15px 40px;
            background: transparent;
            border: 1px solid rgba(0, 255, 255, 0.5);
            color: #00ffff;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            backdrop-filter: blur(5px);
        }

        #startBtn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            transform: scale(1.05);
        }

        /* æ¶æç»“æœå‡ºç°æ—¶çš„å…¨å±çº¢å…‰ç‰¹æ•ˆ */
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 5;
        }
    </style>
</head>
<body>

    <div id="flash"></div>

    <div id="ui-layer">
        <h1 id="mainTitle">AI ç²’å­çµé­‚æµ‹ç»˜</h1>
        <p id="status">åŸºäº WebGL çš„å®æ—¶æƒ…æ„Ÿè¿ç®—å¼•æ“</p>
        <button id="startBtn">å¼€å§‹æ£€æµ‹</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- é…ç½® ---
        const CONFIG = {
            particleCount: 12000,
            particleSize: 0.18,
            color: '#ff69b4' // åˆå§‹æµªæ¼«ç²‰è‰²
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false; // ç¦æ­¢ç¼©æ”¾ä»¥å…ç©¿å¸®
        controls.autoRotate = true;  // è‡ªåŠ¨æ—‹è½¬å¢åŠ æµªæ¼«æ„Ÿ
        controls.autoRotateSpeed = 2.0;

        // --- ç²’å­ç³»ç»Ÿ ---
        let particles;
        let positions = [];
        let targetPositions = []; 
        
        // åˆå§‹åŒ–ï¼šå…ˆç”Ÿæˆä¸€ä¸ªçˆ±å¿ƒ
        const geometry = new THREE.BufferGeometry();
        const heartPoints = getHeartPoints(); // è·å–çˆ±å¿ƒåæ ‡

        // å¡«å…… Buffer
        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            positions.push((Math.random() - 0.5) * 100); // åˆå§‹ä½ç½®ä¹±é£ï¼Œç¨åèšåˆæˆçˆ±å¿ƒ
        }
        targetPositions = Float32Array.from(heartPoints); // ç›®æ ‡è®¾å®šä¸ºçˆ±å¿ƒ

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: CONFIG.color,
            size: CONFIG.particleSize,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- å½¢çŠ¶ç®—æ³• ---

        // 1. çˆ±å¿ƒç®—æ³•
        function getHeartPoints() {
            const points = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // ç®€å•çš„å¿ƒå½¢åˆ†å¸ƒ
                let x = (Math.random() - 0.5) * 2; 
                let y = (Math.random() - 0.5) * 2; 
                let z = (Math.random() - 0.5) * 2;
                
                // è¿‡æ»¤å‡ºåœ¨å¿ƒå½¢æ–¹ç¨‹å†…çš„ç‚¹
                // (x^2 + y^2 - 1)^3 - x^2 * y^3 <= 0 (2D) -> æ‰©å±•åˆ° 3D
                let retry = 0;
                while (retry < 100) {
                     x = (Math.random() - 0.5) * 3.5;
                     y = (Math.random() - 0.5) * 3.5;
                     z = (Math.random() - 0.5) * 3.5;
                     const a = x*x + 2.25*y*y + z*z - 1;
                     if (a*a*a - x*x*z*z*z - 0.1125*y*y*z*z*z <= 0) {
                         points.push(x * 8, y * 8, z * 8); // æ”¾å¤§
                         break;
                     }
                     retry++;
                }
                if (points.length < (i + 1) * 3) { points.push(0,0,0); }
            }
            // è¡¥é½
            while(points.length < CONFIG.particleCount * 3) points.push(0,0,0);
            return points;
        }

        // 2. æ–‡å­—/å›¾ç‰‡ç²’å­åŒ– (å°ä¸‘/æ–‡å­—)
        function getTextPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#ffffff';
            ctx.font = '180px Arial'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 128); // å±…ä¸­ç»˜åˆ¶

            const imageData = ctx.getImageData(0, 0, 256, 256);
            const data = imageData.data;
            const validPixels = [];

            // æ‰«æåƒç´ 
            for (let y = 0; y < 256; y += 2) {
                for (let x = 0; x < 256; x += 2) {
                    if (data[(y * 256 + x) * 4] > 100) { // äº®åº¦å¤§äº100çš„åƒç´ 
                        validPixels.push({x, y});
                    }
                }
            }

            const points = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                if (validPixels.length > 0) {
                    const pixel = validPixels[Math.floor(Math.random() * validPixels.length)];
                    points.push((pixel.x - 128) * 0.12); // å±…ä¸­å¹¶ç¼©æ”¾
                    points.push(-(pixel.y - 128) * 0.12); // Yè½´åè½¬
                    points.push((Math.random() - 0.5) * 1); // å‹æ‰ä¸€ç‚¹ï¼Œç±»ä¼¼æµ®é›•
                } else {
                    points.push(0,0,0);
                }
            }
            return points;
        }

        // --- äº¤äº’ä¸åŠ¨ç”»å¾ªç¯ ---
        
        const uiTitle = document.getElementById('mainTitle');
        const uiStatus = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const flash = document.getElementById('flash');

        // æ ¸å¿ƒæ¶ææµç¨‹
        startBtn.addEventListener('click', () => {
            // 1. æ”¹å˜çŠ¶æ€
            startBtn.style.display = 'none'; // éšè—æŒ‰é’®
            uiTitle.innerText = "æ­£åœ¨è§£ææ·±å±‚æ„è¯†...";
            uiStatus.innerText = "Accessing Neural Database...";
            
            // åŠ é€Ÿæ—‹è½¬
            controls.autoRotateSpeed = 20.0;
            
            // 2. æ¨¡æ‹Ÿè®¡ç®—è¿‡ç¨‹ (2ç§’åå‡ºç»“æœ)
            setTimeout(() => {
                // 3. æ¶ææ—¶åˆ»ï¼
                // åˆ‡æ¢åˆ°å°ä¸‘æ•°æ® (ä½ å¯ä»¥æŠŠ "ğŸ¤¡" æ”¹æˆ "SB" æˆ–å…¶ä»–å­—)
                const clownPoints = getTextPoints("ğŸ¤¡"); 
                targetPositions = Float32Array.from(clownPoints);

                // æ”¹å˜é¢œè‰² -> å˜æˆæ˜¾çœ¼çš„ç»¿è‰² æˆ– çº¢è‰²
                material.color.set('#00ff00'); 
                
                // åœæ­¢ç–¯ç‹‚æ—‹è½¬ï¼Œæ–¹ä¾¿çœ‹æ¸…
                controls.autoRotateSpeed = 2.0; 
                
                // UI å˜åŒ–
                uiTitle.innerText = "æ£€æµ‹å®Œæˆ";
                uiTitle.style.color = "#00ff00";
                uiStatus.innerText = "ç»“æœï¼šçº¯æ­£çš„å°ä¸‘ (Clown)";
                uiStatus.style.color = "#00ff00";

                // å±å¹•é—ªçƒä¸€ä¸‹
                flash.style.opacity = 0.5;
                setTimeout(() => flash.style.opacity = 0, 300);

            }, 2500);
        });

        // é¼ æ ‡äº¤äº’ (ä¿æŒ)
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const currentPositions = geometry.attributes.position.array;

            // é¼ æ ‡ä½ç½®
            raycaster.setFromCamera(mouse, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;

                // æ’å€¼ç§»åŠ¨åˆ°ç›®æ ‡å½¢çŠ¶
                currentPositions[i3] += (targetPositions[i3] - currentPositions[i3]) * 0.08;
                currentPositions[i3+1] += (targetPositions[i3+1] - currentPositions[i3+1]) * 0.08;
                currentPositions[i3+2] += (targetPositions[i3+2] - currentPositions[i3+2]) * 0.08;

                // å‘¼å¸æ•ˆæœ
                currentPositions[i3] += Math.sin(time * 2 + currentPositions[i3+1]) * 0.005;

                // é¼ æ ‡äº’åŠ¨ (æ–¥åŠ›)
                const dx = currentPositions[i3] - intersectPoint.x;
                const dy = currentPositions[i3+1] - intersectPoint.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 4) {
                    const force = (4 - dist) * 0.5;
                    currentPositions[i3] += dx * force * 0.2;
                    currentPositions[i3+1] += dy * force * 0.2;
                }
            }
            
            geometry.attributes.position.needsUpdate = true;
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // çª—å£é€‚é…
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
