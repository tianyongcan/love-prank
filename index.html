<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas & My Secret</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center bottom, #1b2735 0%, #090a0f 100%);
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        #header {
            margin-top: 30px;
            text-align: center;
        }

        h1 {
            color: #fff;
            font-family: 'Cinzel', serif; /* å¯ä»¥å¼•å…¥è°·æ­Œå­—ä½“ */
            font-weight: 300;
            font-size: 3rem;
            text-shadow: 0 0 15px rgba(255,215,0, 0.6), 0 0 30px rgba(255,0,0, 0.4);
            letter-spacing: 5px;
            margin: 0;
        }
        
        p.hint {
            color: rgba(255,255,255,0.7);
            font-size: 0.9rem;
            margin-top: 10px;
        }

        /* çº¸æ¡å†…å®¹å±‚ (é»˜è®¤éšè—) */
        #paper-message {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 300px;
            min-height: 400px;
            /* è¿™é‡Œä¸ç›´æ¥ç”¨èƒŒæ™¯è‰²ï¼Œè€Œæ˜¯é ç²’å­æ”¯æ’‘ï¼Œç”¨ä¸€ç‚¹é˜´å½±å¢åŠ å±‚æ¬¡ */
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            text-align: center;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€åˆ° Three.js */
            opacity: 0;
            transition: all 1s ease-in-out;
            z-index: 20;
        }
        
        /* çº¸æ¡æ˜¾ç°æ—¶çš„çŠ¶æ€ */
        #paper-message.active {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        #message-text {
            color: #fff;
            font-size: 1.5rem;
            line-height: 2;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            /* æ‰“å­—æœºæ•ˆæœå…‰æ ‡ */
            border-right: 2px solid rgba(255,255,255,0.8);
            white-space: pre-wrap;
            overflow: hidden;
        }

        #close-btn {
            pointer-events: auto;
            margin-top: 30px;
            padding: 8px 20px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.5);
            color: rgba(255,255,255,0.8);
            border-radius: 20px;
            cursor: pointer;
            transition: 0.3s;
            font-size: 0.9rem;
        }
        #close-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: #fff;
            color: #fff;
        }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="ui-layer">
        <div id="header">
            <h1>Merry Christmas</h1>
            <p class="hint">åœ¨è¿™æ£µæ ‘é‡Œï¼Œè—ç€æˆ‘å¯¹ä½ çš„å¿ƒæ„ (è¯•ç€æ—‹è½¬å’Œå¯»æ‰¾å‘å…‰çš„ç¤¼ç‰©)</p>
        </div>
    </div>

    <div id="paper-message">
        <div id="message-text"></div>
        <button id="close-btn">æ”¶èµ·ä¿¡ä»¶</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import gsap from 'gsap';

        // --- åœºæ™¯è®¾ç½® ---
        const scene = new THREE.Scene();
        // æ·»åŠ è¿·é›¾è¥é€ å†¬æ—¥æ°›å›´
        scene.fog = new THREE.FogExp2(0x090a0f, 0.008);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 80, 350); // åˆå§‹è§†è§’ç¨å¾®ä»°è§†

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // å¼€å¯ toneMapping è®©å‘å…‰æ•ˆæœæ›´å¥½
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 + 0.2; // é™åˆ¶ä¸èƒ½é’»åˆ°åœ°åº•å¤ªå¤š
        controls.minDistance = 100;
        controls.maxDistance = 600;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- å·¥å…·å‡½æ•°ï¼šç”Ÿæˆç®€æ˜“çš„åœ£è¯å…ƒç´ çº¹ç† ---
        // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå»ºè®®ç”¨ Photoshop åšå¥½å¥½çœ‹çš„ PNG å›¾ç‰‡ä»£æ›¿è¿™é‡Œ
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = '40px sans-serif';
            // ç»˜åˆ¶ emoji
            if(type === 'snow') ctx.fillText('â„ï¸', 32, 32);
            if(type === 'star') ctx.fillText('ğŸŒŸ', 32, 32);
            if(type === 'gift') ctx.fillText('ğŸ', 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const textures = {
            snow: createTexture('snow'),
            star: createTexture('star'),
            gift: createTexture('gift')
        };

        // --- æ ¸å¿ƒï¼šåœ£è¯æ ‘ç²’å­ç³»ç»Ÿ ---
        const treeConfig = {
            count: 4000,
            height: 250,
            radius: 100,
            specialCount: 5 // è—å‡ ä¸ªç‰¹æ®Šçš„â€œç¤¼ç‰©â€ç²’å­
        };

        const treeGeometry = new THREE.BufferGeometry();
        const treePositions = new Float32Array(treeConfig.count * 3);
        const treeTargetPositions = new Float32Array(treeConfig.count * 3); // ç”¨äºå˜å½¢çš„ç›®æ ‡ä½ç½®
        const treeSizes = new Float32Array(treeConfig.count);
        const treeColors = new Float32Array(treeConfig.count * 3);
        const treeTypes = new Float32Array(treeConfig.count); // å­˜å‚¨çº¹ç†ç±»å‹ç´¢å¼•

        const colorPalette = [
            new THREE.Color('#ffffff'), // ç™½é›ª
            new THREE.Color('#f1c40f'), // é‡‘æ˜Ÿ
            new THREE.Color('#e74c3c'), // çº¢ç¤¼ç‰©
            new THREE.Color('#2ecc71')  // ç»¿å¶è‰²
        ];

        for (let i = 0; i < treeConfig.count; i++) {
            const i3 = i * 3;
            // åœ£è¯æ ‘ç®—æ³•ï¼šèºæ—‹å‘ä¸Šå¹¶ç¼©å°åŠå¾„
            const angle = (i / treeConfig.count) * Math.PI * 40 + Math.random() * 0.5;
            const heightRatio = i / treeConfig.count; // 0 åˆ° 1
            const currentRadius = treeConfig.radius * (1 - heightRatio) + Math.random() * 10;
            
            const x = Math.cos(angle) * currentRadius;
            const y = heightRatio * treeConfig.height - treeConfig.height / 2;
            const z = Math.sin(angle) * currentRadius;

            // åˆå§‹ä½ç½®
            treePositions[i3] = x + (Math.random() - 0.5) * 20;
            treePositions[i3+1] = y + (Math.random() - 0.5) * 20;
            treePositions[i3+2] = z + (Math.random() - 0.5) * 20;
            
            // è®°å½•æ ‘å½¢æ€çš„ä½ç½®
            treeTargetPositions[i3] = treePositions[i3];
            treeTargetPositions[i3+1] = treePositions[i3+1];
            treeTargetPositions[i3+2] = treePositions[i3+2];

            // å¤§å°å’Œé¢œè‰²
            treeSizes[i] = Math.random() * 3 + 2;
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            treeColors[i3] = color.r; treeColors[i3+1] = color.g; treeColors[i3+2] = color.b;

            // åˆ†é…çº¹ç†ç±»å‹ (å¤§éƒ¨åˆ†æ˜¯é›ªèŠ±ï¼Œå°‘éƒ¨åˆ†æ˜Ÿæ˜Ÿï¼Œæå°‘ç¤¼ç‰©)
            const rand = Math.random();
            if (rand > 0.95) treeTypes[i] = 2; // gift
            else if (rand > 0.85) treeTypes[i] = 1; // star
            else treeTypes[i] = 0; // snow
        }

        treeGeometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
        treeGeometry.setAttribute('size', new THREE.BufferAttribute(treeSizes, 1));
        treeGeometry.setAttribute('color', new THREE.BufferAttribute(treeColors, 3));
        treeGeometry.setAttribute('type', new THREE.BufferAttribute(treeTypes, 1));

        // è‡ªå®šä¹‰ç€è‰²å™¨æè´¨ (ä¸ºäº†æ”¯æŒä¸åŒçº¹ç†è´´å›¾å’Œå‘å…‰)
        const treeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTexSnow: { value: textures.snow },
                uTexStar: { value: textures.star },
                uTexGift: { value: textures.gift },
                uMouse: { value: new THREE.Vector3(9999,9999,9999) } // é¼ æ ‡äº’åŠ¨ä½ç½®
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                attribute float type;
                varying vec3 vColor;
                varying float vType;
                uniform float uTime;
                uniform vec3 uMouse;

                void main() {
                    vColor = color;
                    vType = type;
                    vec3 pos = position;
                    
                    // ç®€æ˜“çš„é¼ æ ‡æ–¥åŠ›æ•ˆæœ
                    float dist = distance(pos, uMouse);
                    float force = smoothstep(100.0, 0.0, dist);
                    vec3 dir = normalize(pos - uMouse);
                    pos += dir * force * 30.0;

                    // è½»å¾®çš„å‘¼å¸æµ®åŠ¨
                    pos.y += sin(uTime * 2.0 + pos.x * 0.05) * 2.0;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    // è·ç¦»ç›¸æœºè¶Šè¿‘è¶Šå¤§
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexSnow;
                uniform sampler2D uTexStar;
                uniform sampler2D uTexGift;
                varying vec3 vColor;
                varying float vType;

                void main() {
                    vec4 texColor;
                    // æ ¹æ®ç±»å‹é€‰æ‹©çº¹ç†
                    if(vType < 0.5) texColor = texture2D(uTexSnow, gl_PointCoord);
                    else if(vType < 1.5) texColor = texture2D(uTexStar, gl_PointCoord);
                    else texColor = texture2D(uTexGift, gl_PointCoord);

                    if (texColor.a < 0.5) discard; // é€æ˜å‰”é™¤

                    // é¢œè‰²å åŠ å¹¶å¢åŠ ä¸€ç‚¹å‘å…‰æ„Ÿ
                    gl_FragColor = vec4(vColor * texColor.rgb * 1.5, texColor.a);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const tree = new THREE.Points(treeGeometry, treeMaterial);
        scene.add(tree);

        // --- ç‰¹æ®Šäº¤äº’ç‚¹ (è—åœ¨æ ‘é‡Œçš„ç§˜å¯†) ---
        const specialPoints = [];
        const specialMaterial = new THREE.SpriteMaterial({ 
            map: textures.gift, 
            color: 0xffd700, // é‡‘è‰²
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false // ç¡®ä¿å®ƒæ€»èƒ½è¢«çœ‹è§
        });

        for(let i=0; i<treeConfig.specialCount; i++) {
            const idx = Math.floor(Math.random() * treeConfig.count) * 3;
            const sprite = new THREE.Sprite(specialMaterial);
            // æ”¾åœ¨æ ‘çš„è¡¨é¢ä½ç½®
            sprite.position.set(treeTargetPositions[idx], treeTargetPositions[idx+1], treeTargetPositions[idx+2]);
            sprite.scale.set(15, 15, 1); // æ¯”æ™®é€šç²’å­å¤§
            sprite.userData.isSecret = true; // æ ‡è®°
            scene.add(sprite);
            specialPoints.push(sprite);
        }


        // --- èƒŒæ™¯é›ªèŠ±ç³»ç»Ÿ (è¥é€ æ°›å›´) ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(2000 * 3);
        const snowVel = new Float32Array(2000); // ä¸‹è½é€Ÿåº¦
        for(let i=0; i<2000; i++) {
            snowPos[i*3] = (Math.random()-0.5)*1000;
            snowPos[i*3+1] = Math.random()*1000 - 500;
            snowPos[i*3+2] = (Math.random()-0.5)*1000;
            snowVel[i] = Math.random() * 1 + 0.5;
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({
            size: 4, map: textures.snow, transparent: true, opacity: 0.6, depthWrite:false
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);


        // --- äº¤äº’ä¸åŠ¨ç”»é€»è¾‘ ---
        let isPaperMode = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // ç”¨äºé¼ æ ‡äº’åŠ¨è®¡ç®—çš„å¹³é¢

        // è¡¨ç™½å†…å®¹ (åœ¨è¿™é‡Œä¿®æ”¹ï¼)
        const messages = [
            "Merry Christmas, my dear.",
            "è¿™æ£µæ ‘å¾ˆç¾ï¼Œä½†ä¸å¦‚ä½ ä¸‡åˆ†ä¹‹ä¸€ã€‚",
            "ä¸éœ€è¦åœ£è¯è€äººï¼Œ",
            "å› ä¸ºä½ å°±æ˜¯æˆ‘æœ€å¥½çš„ç¤¼ç‰©ã€‚",
            "æœªæ¥çš„æ¯ä¸€ä¸ªåœ£è¯èŠ‚ï¼Œ",
            "æˆ‘éƒ½æƒ³å’Œä½ ä¸€èµ·çœ‹é›ªã€‚",
            "â¤ çˆ±ä½ çš„ [ä½ çš„åå­—] â¤"
        ];
        const paperMessage = document.getElementById('paper-message');
        const messageText = document.getElementById('message-text');
        const closeBtn = document.getElementById('close-btn');

        // æ‰“å­—æœºæ•ˆæœ
        function typeWriter(textArray, element) {
            element.innerHTML = '';
            let lineIndex = 0;
            let charIndex = 0;
            
            function type() {
                if (lineIndex < textArray.length) {
                    if (charIndex < textArray[lineIndex].length) {
                        element.innerHTML += textArray[lineIndex].charAt(charIndex);
                        charIndex++;
                        setTimeout(type, 100); // æ‰“å­—é€Ÿåº¦
                    } else {
                        element.innerHTML += '<br>'; // æ¢è¡Œ
                        lineIndex++;
                        charIndex = 0;
                        setTimeout(type, 500); // æ¢è¡Œåœé¡¿
                    }
                } else {
                     element.style.borderRight = 'none'; // ç»“æŸç§»é™¤å…‰æ ‡
                }
            }
            type();
        }

        // ç‚¹å‡»äº‹ä»¶ï¼šå¯»æ‰¾ç§˜å¯†
        window.addEventListener('click', (e) => {
            if(isPaperMode) return; // å¦‚æœå·²ç»æ˜¯ä¿¡çº¸æ¨¡å¼ï¼Œä¸å¤„ç†

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(specialPoints);

            if(intersects.length > 0) {
                // æ‰¾åˆ°äº†ï¼å¼€å§‹å˜å½¢
                transformToPaper();
            }
        });

        // æ ¸å¿ƒåŠ¨ç”»ï¼šä»æ ‘å˜æˆçº¸æ¡
        function transformToPaper() {
            isPaperMode = true;
            controls.autoRotate = false;
            controls.enableRotate = false; // ç¦æ­¢æ—‹è½¬
            
            // éšè—ç‰¹æ®Šç‚¹å’Œæ ‡é¢˜
            specialPoints.forEach(p => p.visible = false);
            gsap.to('#header', { opacity: 0, duration: 1 });

            // 1. è®¡ç®—çº¸æ¡çš„å½¢æ€ (ä¸€ä¸ªé•¿æ–¹å½¢å¹³é¢)
            const paperWidth = 180; 
            const paperHeight = 260;
            const cols = 50;
            const rows = Math.floor(treeConfig.count / cols);

            for(let i=0; i<treeConfig.count; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                // å°†ç²’å­æ’åˆ—æˆçº¸å¼ å¹³é¢
                const x = (col / cols - 0.5) * paperWidth;
                const y = (row / rows - 0.5) * paperHeight;
                const z = (Math.random() - 0.5) * 5; // ç¨å¾®æœ‰ç‚¹åšåº¦

                // ä½¿ç”¨ GSAP å°†æ¯ä¸ªç²’å­ç§»åŠ¨åˆ°æ–°çš„ä½ç½®
                gsap.to(treePositions, {
                    [i*3]: x,
                    [i*3+1]: y,
                    [i*3+2]: z,
                    duration: 2.5 + Math.random(), // éšæœºæ—¶é—´å¢åŠ åŠ¨æ„Ÿ
                    ease: "power3.inOut",
                    onUpdate: () => {
                        treeGeometry.attributes.position.needsUpdate = true;
                    }
                });
                // ç»Ÿä¸€é¢œè‰²ä¸ºé‡‘è‰²ï¼Œå¹¶å˜å°
                 gsap.to(treeSizes, {[i]: 1.5, duration: 2});
                 gsap.to(treeColors, {[i*3]: 1.0, [i*3+1]: 0.84, [i*3+2]: 0.0, duration: 2});
            }
            treeGeometry.attributes.size.needsUpdate = true;
            treeGeometry.attributes.color.needsUpdate = true;

            // ç›¸æœºç§»åŠ¨åˆ°æ­£é¢
            gsap.to(camera.position, { x: 0, y: 0, z: 300, duration: 2 });
            gsap.to(camera.rotation, { x: 0, y: 0, z: 0, duration: 2 });

            // æ˜¾ç¤º DOM çº¸æ¡å†…å®¹
            setTimeout(() => {
                paperMessage.classList.add('active');
                typeWriter(messages, messageText);
            }, 2500);
        }

        // æ”¶èµ·ä¿¡ä»¶ï¼Œå˜å›åœ£è¯æ ‘
        closeBtn.addEventListener('click', () => {
             isPaperMode = false;
             paperMessage.classList.remove('active');
             messageText.innerHTML = ''; 
             messageText.style.borderRight = '2px solid rgba(255,255,255,0.8)';
             gsap.to('#header', { opacity: 1, duration: 1, delay: 2 });

             // ç²’å­å½’ä½
             for(let i=0; i<treeConfig.count; i++) {
                 gsap.to(treePositions, {
                    [i*3]: treeTargetPositions[i*3],
                    [i*3+1]: treeTargetPositions[i*3+1],
                    [i*3+2]: treeTargetPositions[i*3+2],
                    duration: 2 + Math.random(),
                    ease: "elastic.out(1, 0.5)", // å¼¹ç°§æ•ˆæœå½’ä½
                    onUpdate: () => {
                        treeGeometry.attributes.position.needsUpdate = true;
                    }
                 });
                 // æ¢å¤å¤§å°å’Œé¢œè‰² (è¿™é‡Œç®€å•å¤„ç†ï¼Œæ¢å¤éšæœºè‰²å’Œå¤§å°)
                 gsap.to(treeSizes, {[i]: Math.random() * 3 + 2, duration: 2});
                 const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                 gsap.to(treeColors, {[i*3]: color.r, [i*3+1]: color.g, [i*3+2]: color.b, duration: 2});
             }
             treeGeometry.attributes.size.needsUpdate = true;
             treeGeometry.attributes.color.needsUpdate = true;

             setTimeout(() => {
                 specialPoints.forEach(p => p.visible = true);
                 controls.enableRotate = true;
                 controls.autoRotate = true;
             }, 2500);
        });


        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ (ç”¨äºæ‰°åŠ¨ç²’å­)
        window.addEventListener('mousemove', (e) => {
            if(isPaperMode) return;
            // è®¡ç®—é¼ æ ‡åœ¨ 3D ä¸–ç•Œä¸­çš„æŠ•å½±ä½ç½®
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);
            treeMaterial.uniforms.uMouse.value = intersectPoint;
        });

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        function animate() {
            const time = clock.getElapsedTime();
            treeMaterial.uniforms.uTime.value = time;

            // ç‰¹æ®Šç‚¹é—ªçƒ
            if(!isPaperMode) {
                specialPoints.forEach((p, i) => {
                    p.scale.setScalar(15 + Math.sin(time*3 + i)*3);
                    p.material.opacity = 0.8 + Math.sin(time*3 + i)*0.2;
                });
            }

            // é›ªèŠ±ä¸‹è½æ›´æ–°
            const snowPositions = snowGeo.attributes.position.array;
            for(let i=0; i<2000; i++) {
                snowPositions[i*3+1] -= snowVel[i];
                if(snowPositions[i*3+1] < -500) snowPositions[i*3+1] = 500; // å¾ªç¯
            }
            snowGeo.attributes.position.needsUpdate = true;

            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // çª—å£é€‚é…
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
