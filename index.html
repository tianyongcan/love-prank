<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        /* ç®€å•çš„åŠ è½½æç¤º */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 14px; pointer-events: none; transition: opacity 0.5s;
        }
        /* æ¶ææ—¶çš„è¦†ç›–å±‚ï¼ˆå¯é€‰ï¼‰ */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none;
            box-shadow: inset 0 0 100px red;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="loading">æ­£åœ¨åŠ è½½ç²’å­å¼•æ“...</div>
    <div id="overlay"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // --- é…ç½®åŒº ---
        const CONFIG = {
            particleCount: 15000,
            particleSize: 0.15,
            color: '#00ffff',
            bloom: true,
            mouseInteraction: true,
            model: 'galaxy' // åˆå§‹æ¨¡å‹
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ---
        let particles;
        let positions = [];
        let targetPositions = []; // ç›®æ ‡å½¢çŠ¶çš„ä½ç½®æ•°æ®
        let speeds = []; // ç²’å­ç§»åŠ¨é€Ÿåº¦
        
        const geometry = new THREE.BufferGeometry();
        
        // åˆå§‹åŒ–ç²’å­ä½ç½®ï¼ˆéšæœºåˆ†å¸ƒï¼‰
        for (let i = 0; i < CONFIG.particleCount; i++) {
            positions.push((Math.random() - 0.5) * 100);
            positions.push((Math.random() - 0.5) * 100);
            positions.push((Math.random() - 0.5) * 100);
            speeds.push(Math.random() * 0.05 + 0.02);
        }
        
        // å¡«å…… Buffer
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        targetPositions = Float32Array.from(positions); // åˆå§‹ç›®æ ‡å°±æ˜¯å½“å‰ä½ç½®

        // æè´¨
        const material = new THREE.PointsMaterial({
            color: CONFIG.color,
            size: CONFIG.particleSize,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- å½¢çŠ¶ç”Ÿæˆç®—æ³• (Math & Canvas) ---

        // 1. çƒä½“/æ˜Ÿç³»
        function getGalaxyPoints() {
            const points = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 10 + Math.random() * 2;
                points.push(r * Math.sin(phi) * Math.cos(theta));
                points.push(r * Math.sin(phi) * Math.sin(theta));
                points.push(r * Math.cos(phi));
            }
            return points;
        }

        // 2. çˆ±å¿ƒ (æ•°å­¦å…¬å¼)
        function getHeartPoints() {
            const points = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let x, y, z;
                // ä½¿ç”¨æ‹’ç»é‡‡æ ·æ³•è®©çˆ±å¿ƒå†…éƒ¨å‡åŒ€
                let done = false;
                while(!done) {
                    let u = (Math.random() * 2 - 1) * 2; // x range
                    let v = (Math.random() * 2 - 1) * 2; // y range
                    // Heart formula (2D profile rotated or extruded)
                    // ç®€åŒ–ç‰ˆ 3D Heart
                    const t = Math.random() * Math.PI * 2;
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    // z = random thickness
                    
                    // è¿™ç§åªæ˜¯çº¿æ¡†ï¼Œæˆ‘ä»¬ç”¨éšæœºå¡«å……
                     x = (Math.random() - 0.5) * 4;
                     y = (Math.random() - 0.5) * 4;
                     z = (Math.random() - 0.5) * 4;
                     
                     // ç®€å•çˆ±å¿ƒæ–¹ç¨‹æ£€æµ‹
                     // (x^2 + 9/4y^2 + z^2 - 1)^3 - x^2z^3 - 9/80y^2z^3 < 0
                     // è°ƒæ•´ç¼©æ”¾
                     const x2 = x * 1.5; 
                     const y2 = y * 1.5;
                     const z2 = z * 1.5;
                     
                     const a = x2*x2 + 2.25*y2*y2 + z2*z2 - 1;
                     if (a*a*a - x2*x2*z2*z2*z2 - 0.1125*y2*y2*z2*z2*z2 <= 0) {
                         points.push(x * 10, y * 10, z * 10);
                         done = true;
                     }
                }
                if(points.length >= CONFIG.particleCount * 3) break;
            }
            // è¡¥é½ä¸è¶³çš„ç‚¹
            while(points.length < CONFIG.particleCount * 3) {
                points.push(0,0,0);
            }
            return points;
        }

        // 3. åœŸæ˜Ÿ (çƒä½“ + ç¯)
        function getSaturnPoints() {
            const points = [];
            const ringCount = Math.floor(CONFIG.particleCount * 0.4);
            const sphereCount = CONFIG.particleCount - ringCount;

            // æœ¬ä½“
            for(let i=0; i<sphereCount; i++){
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 6;
                points.push(r * Math.sin(phi) * Math.cos(theta));
                points.push(r * Math.sin(phi) * Math.sin(theta));
                points.push(r * Math.cos(phi));
            }
            // ç¯
            for(let i=0; i<ringCount; i++){
                const angle = Math.random() * Math.PI * 2;
                const r = 10 + Math.random() * 6; // Ring radius
                points.push(r * Math.cos(angle));
                points.push((Math.random()-0.5) * 0.5); // Flat ring
                points.push(r * Math.sin(angle));
            }
            return points;
        }

        // 4. æ–‡å­—/å›¾ç‰‡ç²’å­åŒ– (æ ¸å¿ƒæ¶æåŠŸèƒ½)
        // å°†æ–‡å­—æ¸²æŸ“åˆ° canvasï¼Œè¯»å–åƒç´ ï¼Œè½¬æ¢ä¸ºç²’å­åæ ‡
        function getTextPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 200;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 200, 200);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 120px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 100, 100);

            const imageData = ctx.getImageData(0, 0, 200, 200);
            const data = imageData.data;
            const validPixels = [];

            for (let y = 0; y < 200; y += 2) { // é‡‡æ ·æ­¥é•¿
                for (let x = 0; x < 200; x += 2) {
                    if (data[(y * 200 + x) * 4] > 128) {
                        validPixels.push({x, y});
                    }
                }
            }

            const points = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // ä»æœ‰æ•ˆåƒç´ ä¸­éšæœºå–ä¸€ä¸ª
                const pixel = validPixels[Math.floor(Math.random() * validPixels.length)];
                // æ˜ å°„åˆ° 3D ç©ºé—´
                if (pixel) {
                    points.push((pixel.x - 100) * 0.15);
                    points.push(-(pixel.y - 100) * 0.15); // Yè½´ç¿»è½¬
                    points.push((Math.random() - 0.5) * 2); // ç¨å¾®æœ‰ç‚¹åšåº¦
                } else {
                    points.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
                }
            }
            return points;
        }

        // --- äº¤äº’é€»è¾‘ ---
        
        const models = {
            'æ˜Ÿç³» (Galaxy)': getGalaxyPoints,
            'ç ´ç¢çš„å¿ƒ (Heart)': getHeartPoints,
            'åœŸæ˜Ÿ (Saturn)': getSaturnPoints,
            // æ¶æå…¥å£ï¼šåå­—èµ·å¾—ç‰¹åˆ«é«˜å¤§ä¸Š
            'âœ¨ çµé­‚æŠ•å½± (AI Scan)': () => getTextPoints("ğŸ¤¡"), // è¿™é‡Œå¯ä»¥æ”¹æˆ "SB" æˆ– "ç©·"
            'å…³äºä½œè€… (About)': () => getTextPoints("å¸…") 
        };

        function switchModel(name) {
            const generator = models[name];
            if (generator) {
                const newPos = generator();
                targetPositions = Float32Array.from(newPos);
                
                // æ¶æç‰¹æ•ˆï¼šå¦‚æœæ˜¯å°ä¸‘ï¼ŒæŠŠé¢œè‰²æ”¹æˆçº¢è‰²
                if (name === 'âœ¨ çµé­‚æŠ•å½± (AI Scan)') {
                    CONFIG.color = '#ff0000'; // è­¦ç¤ºçº¢
                    CONFIG.particleSize = 0.25; // å˜å¤§
                    material.size = 0.25;
                    material.color.set('#ff0000');
                    document.getElementById('overlay').style.display = 'block'; // å¼€å¯çº¢è‰²è­¦æŠ¥æ°›å›´
                    setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 500);
                } else {
                    material.color.set(CONFIG.color); // æ¢å¤é¢œè‰²
                }
            }
        }

        // --- é¼ æ ‡äº¤äº’ ---
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // --- GUI é¢æ¿ ---
        const gui = new GUI({ title: '3D ç²’å­æ§åˆ¶å°' });
        
        gui.add(CONFIG, 'model', Object.keys(models)).name('é€‰æ‹©æ¨¡å‹').onChange(switchModel);
        
        gui.addColor(CONFIG, 'color').name('ç²’å­é¢œè‰²').onChange(c => {
            material.color.set(c);
        });
        
        gui.add(CONFIG, 'particleSize', 0.01, 0.5).name('ç²’å­å¤§å°').onChange(s => {
            material.size = s;
        });

        const folder = gui.addFolder('é«˜çº§è®¾ç½®');
        folder.add(CONFIG, 'mouseInteraction').name('é¼ æ ‡æ‰°åŠ¨');
        
        const btn = {
            fullscreen: () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            }
        };
        gui.add(btn, 'fullscreen').name('å…¨å±æ²‰æµ¸');

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const positionsAttribute = geometry.attributes.position;
            const currentPositions = positionsAttribute.array;

            // é¼ æ ‡å°„çº¿æ£€æµ‹ï¼ˆç”¨äºæ‰°åŠ¨ï¼‰
            raycaster.setFromCamera(mouse, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;

                // 1. ç›®æ ‡ä½ç½®æ’å€¼ (Morphing)
                // ç®€å•çš„ç¼“åŠ¨ç®—æ³•ï¼šå½“å‰ä½ç½® += (ç›®æ ‡ä½ç½® - å½“å‰ä½ç½®) * é€Ÿåº¦
                currentPositions[i3] += (targetPositions[i3] - currentPositions[i3]) * 0.05;
                currentPositions[i3+1] += (targetPositions[i3+1] - currentPositions[i3+1]) * 0.05;
                currentPositions[i3+2] += (targetPositions[i3+2] - currentPositions[i3+2]) * 0.05;

                // 2. å™ªå£°æ¼‚æµ® (å‘¼å¸æ„Ÿ)
                currentPositions[i3] += Math.sin(time + currentPositions[i3+1]) * 0.01;
                currentPositions[i3+1] += Math.cos(time + currentPositions[i3]) * 0.01;

                // 3. é¼ æ ‡äº¤äº’ (æ–¥åŠ›)
                if (CONFIG.mouseInteraction) {
                    const dx = currentPositions[i3] - intersectPoint.x;
                    const dy = currentPositions[i3+1] - intersectPoint.y;
                    const dz = currentPositions[i3+2] - intersectPoint.z; // 3D distance check roughly
                    
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 5) {
                        const force = (5 - dist) * 0.5;
                        currentPositions[i3] += dx * force * 0.1;
                        currentPositions[i3+1] += dy * force * 0.1;
                        currentPositions[i3+2] += (Math.random()-0.5) * force; // Zè½´ä¹±é£
                    }
                }
            }

            // æ•´ä½“æ—‹è½¬
            particles.rotation.y = time * 0.05;
            
            positionsAttribute.needsUpdate = true;
            controls.update();
            renderer.render(scene, camera);
        }

        document.getElementById('loading').style.opacity = 0;
        switchModel('æ˜Ÿç³» (Galaxy)'); // é»˜è®¤æ¨¡å‹
        animate();

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
